<<<<<<< HEAD
taskKey="com.javarush.task.task30.task3008.big22"

Чат (22)

Итак, подведем итог:
•	Ты написал сервер для обмена текстовыми сообщениями.
•	Ты написал консольный клиент, который умеет подключаться к серверу и
обмениваться сообщениями с другими участниками.
•	Ты написал бот клиента, который может принимать запросы и отправлять данные о
текущей дате и времени.
•	Ты написал клиента для чата с графическим интерфейсом.

Что можно добавить или улучшить:
•	Можно добавить поддержку приватных сообщений (когда сообщение отправляется не
всем, а какому-то конкретному участнику).
•	Можно расширить возможности бота, попробовать научить его отвечать на
простейшие вопросы или время от времени отправлять шутки.
•	Добавить возможность пересылки файлов между пользователями.
•	Добавить контекстное меню в графический клиент, например, для отправки
приватного сообщения кому-то из списка участников.
•	Добавить раскраску сообщений в графическом клиенте в зависимости от отправителя.
•	Добавить блокировку сервером участников за что-либо, например, ненормативную
лексику в сообщениях.
•	Добавить еще миллион фич и полезностей!

Ты научился:
•	Работать с сокетами.
•	Пользоваться сериализацией и десериализацией.
•	Создавать многопоточные приложения, синхронизировать их, применять модификатор
volatile, пользоваться классами из библиотеки java.util.concurrent.
•	Применять паттерн MVC.
•	Использовать внутренние и вложенные классы.
•	Работать с библиотекой Swing.
•	Применять классы Calendar и SimpleDateFormat.

Так держать!


Требования:
1.	Поздравляю, чат готов!


Чат (21)

У меня есть отличнейшая новость для тебя. Компонент представление (View) уже готов. Я
добавил класс ClientGuiView. Он использует библиотеку javax.swing. Ты должен как следует
разобраться в каждой строчке этого класса. Если тебе все понятно – это замечательно, если
нет – обязательно найди ответы на свои вопросы с помощью дебага, документации или
поиска в Интернет.

Осталось написать компонент контроллер (Controller):
1)	Создай класс ClientGuiController унаследованный от Client.
2)	Создай и инициализируй поле, отвечающее за модель ClientGuiModel
model.
3)	Создай и инициализируй поле, отвечающее за представление ClientGuiView
view. Подумай, что нужно передать в конструктор при инициализации объекта.
4)	Добавь внутренний класс GuiSocketThread унаследованный от SocketThread.
Класс GuiSocketThread должен быть публичным. В нем переопредели следующие
методы:
а)	void processIncomingMessage(String message) – должен устанавливать новое
сообщение у модели и вызывать обновление вывода сообщений у
представления.
б)	void informAboutAddingNewUser(String userName) – должен добавлять нового
пользователя в модель и вызывать обновление вывода пользователей у
отображения.
в)	void informAboutDeletingNewUser(String userName) – должен удалять
пользователя из модели и вызывать обновление вывода пользователей у
отображения.
г)	void notifyConnectionStatusChanged(boolean clientConnected) – должен вызывать
аналогичный метод у представления.
5)	Переопредели методы в классе ClientGuiController:
а)	SocketThread getSocketThread() – должен создавать и возвращать объект типа
GuiSocketThread.
б)	void run() – должен получать объект SocketThread через метод getSocketThread()
и вызывать у него метод run(). Разберись, почему нет необходимости вызывать
метод run в отдельном потоке, как мы это делали для консольного клиента.
в)	getServerAddress(), getServerPort(),getUserName(). Они должны вызывать
одноименные методы из представления (view).
6)	Реализуй метод ClientGuiModel getModel(), который должен возвращать модель.
7)	Реализуй метод main(), который должен создавать новый объект
ClientGuiController и вызывать у него метод run().
Запусти клиента с графическим окном, нескольких консольных клиентов и убедись, что
все работает корректно.



Чат (20)

Консольный клиент мы уже реализовали, чат бота тоже сделали, почему бы не сделать
клиента с графическим интерфейсом? Он будет так же работать с нашим сервером, но
иметь графическое окно, кнопки и т.д.
Итак, приступим. При написании графического клиента будет очень уместно воспользоваться
паттерном MVC (Model-View-Controller). Ты уже должен был с ним сталкиваться, если необходимо,
освежи свои знания про MVC с помощью Интернет. В нашей задаче самая простая реализация
будет у класса, отвечающего за модель (Model).

Давай напишем его:
1)	Создай класс ClientGuiModel в пакете client. Все классы клиента должны быть созданы в этом
пакете.
2)	Добавь в него множество(set) строк в качестве final поля allUserNames.
В нем будет храниться список всех участников чата. Проинициализируй его.
3)	Добавь поле String newMessage, в котором будет храниться новое сообщение,
которое получил клиент.
4)	Добавь геттер для allUserNames, запретив модифицировать возвращенное
множество. Разберись, как это можно сделать с помощью метода класса Collections.
5)	Добавь сеттер и геттер для поля newMessage.
6)	Добавь метод void addUser(String newUserName), который должен добавлять
имя участника во множество, хранящее всех участников.
7)	Добавь метод void deleteUser(String userName), который будет удалять имя
участника из множества.



Чат (19)

Сейчас будем реализовывать класс BotSocketThread, вернее переопределять некоторые
его методы, весь основной функционал он уже унаследовал от SocketThread.

1)	Переопредели метод clientMainLoop():
а)	С помощью метода sendTextMessage() отправь сообщение с текстом
"Привет чатику. Я бот. Понимаю команды: дата, день, месяц, год, время, час, минуты, секунды."
б)	Вызови реализацию clientMainLoop() родительского класса.
2)	Переопредели метод processIncomingMessage(String message). Он должен
следующим образом обрабатывать входящие сообщения:
а)	Вывести в консоль текст полученного сообщения message.
б)	Получить из message имя отправителя и текст сообщения. Они разделены ": ".
в)	Отправить ответ в зависимости от текста принятого сообщения. Если текст
сообщения:
"дата" – отправить сообщение содержащее текущую дату в формате "d.MM.YYYY";
"день" – в формате"d";
"месяц" - "MMMM";
"год" - "YYYY";
"время" - "H:mm:ss";
"час" - "H";
"минуты" - "m";
"секунды" - "s".
Указанный выше формат используй для создания объекта SimpleDateFormat. Для
получения текущей даты необходимо использовать класс Calendar и метод
getTime().
Ответ должен содержать имя клиента, который прислал запрос и ожидает ответ,
например, если Боб отправил запрос "время", мы должны отправить ответ
"Информация для Боб: 12:30:47".
Наш бот готов. Запусти сервер, запусти бота, обычного клиента и убедись, что все работает правильно.
Помни, что message бывают разных  типов и не всегда содержат ":"



Чат (18)

Иногда бывают моменты, что не находится достойного собеседника. Не общаться же с
самим собой :). Давай напишем бота, который будет представлять собой клиента, который
автоматически будет отвечать на некоторые команды. Проще всего реализовать бота,
который сможет отправлять текущее время или дату, когда его кто-то об этом попросит.

С него и начнем:
1)	Создай новый класс BotClient в пакете client. Он должен быть унаследован от
Client.
2)	В классе BotClient создай внутренний класс BotSocketThread унаследованный от
SocketThread. Класс BotSocketThread должен быть публичным.
3)	Переопредели методы:
а)	getSocketThread(). Он должен создавать и возвращать объект класса
BotSocketThread.
б)	shouldSendTextFromConsole(). Он должен всегда возвращать false. Мы не хотим,
чтобы бот отправлял текст введенный в консоль.
в)	getUserName(), метод должен генерировать новое имя бота, например:
date_bot_X, где X – любое число от 0 до 99. Для генерации X используй метод Math.random().
4)	Добавь метод main. Он должен создавать новый объект BotClient и вызывать у
него метод run().



Чат (17)

Последний, но самый главный метод класса SocketThread – это метод void run(). Добавь
его. Его реализация с учетом уже созданных методов выглядит очень просто.

Давай напишем ее:
1)	Запроси адрес и порт сервера с помощью методов getServerAddress() и
getServerPort().
2)	Создай новый объект класса java.net.Socket, используя данные, полученные в
предыдущем пункте.
3)	Создай объект класса Connection, используя сокет из п.17.2.
4)	Вызови метод, реализующий "рукопожатие" клиента с сервером
(clientHandshake()).
5)	Вызови метод, реализующий основной цикл обработки сообщений сервера.
6)	При возникновении исключений IOException или ClassNotFoundException
сообщи главному потоку о проблеме, используя notifyConnectionStatusChanged и false
в качестве параметра.

Клиент готов, можешь запустить сервер, несколько клиентов и проверить как все работает.
=======
taskKey="com.javarush.task.task30.task3008.big13"

Чат (13)

Продолжаем реализацию вспомогательных методов класса Client.

Добавь в класс методы, которые будут доступны классам потомкам,
но не доступны из других классов вне пакета:
1)	String getServerAddress() – должен запросить ввод адреса сервера у
пользователя и вернуть введенное значение. Адрес может быть строкой, содержащей
ip, если клиент и сервер запущен на разных машинах или ‘localhost’, если клиент и
сервер работают на одной машине.
2)	int getServerPort() – должен запрашивать ввод порта сервера и возвращать его.
3)	String getUserName() – должен запрашивать и возвращать имя пользователя.
4)	boolean shouldSendTextFromConsole() – в данной реализации клиента всегда
должен возвращать true (мы всегда отправляем текст введенный в консоль). Этот
метод может быть переопределен, если мы будем писать какой-нибудь другой
клиент, унаследованный от нашего, который не должен отправлять введенный в
консоль текст.
5)	SocketThread getSocketThread() – должен создавать и возвращать новый объект
класса SocketThread.
6)	void sendTextMessage(String text) – создает новое текстовое сообщение,
используя переданный текст и отправляет его серверу через соединение connection.
Если во время отправки произошло исключение IOException, то необходимо вывести
информацию об этом пользователю и присвоить false полю clientConnected.


Требования:
1.	Метод getServerAddress должен возвращать строку (адрес сервера), считанную с консоли.
2.	Метод getServerPort должен возвращать число (порт сервера), считанное с консоли.
3.	Метод getUserName должен возвращать строку (имя пользователя), считанную с консоли.
4.	Метод shouldSendTextFromConsole должен возвращать true.
5.	Метод sendTextMessage должен создавать и отправлять новое текстовое сообщение используя connection и устанавливать флаг clientConnected в false, если во время отправки или создания сообщения возникло исключение IOException.
6.	Метод getSocketThread должен возвращать новый объект типа SocketThread.


Чат (12)

Приступим к написанию клиента. Клиент, в начале своей работы, должен запросить у
пользователя адрес и порт сервера, подсоединиться к указанному адресу, получить запрос
имени от сервера, спросить имя у пользователя, отправить имя пользователя серверу,
дождаться принятия имени сервером. После этого клиент может обмениваться текстовыми
сообщениями с сервером. Обмен сообщениями будет происходить в двух параллельно
работающих потоках. Один будет заниматься чтением из консоли и отправкой
прочитанного серверу, а второй поток будет получать данные от сервера и выводить их в
консоль.

Начнем реализацию клиента:
1)	Создай пакет client. В дальнейшем все классы, отвечающие за реализацию
клиентов, создавай в этом пакете.
2)	Создай класс Client.
3)	Создай внутренний класс SocketThread унаследованный от Thread в классе
Client. Он будет отвечать за поток, устанавливающий сокетное соединение и
читающий сообщения сервера. Класс должен иметь публичный модификатор доступа.
4)	Создай поле Connection connection в классе Client. Используй модификатор
доступа, который позволит обращаться к этому полю из класса потомков, но запретит
обращение из других классов вне пакета.
5)	Добавь приватное поле-флаг boolean clientConnected в класс Client. Проинициализируй его
значением false. В дальнейшем оно будет устанавливаться в true, если клиент
подсоединен к серверу или в false в противном случае. При объявлении этого поля
используй ключевое слово, которое позволит гарантировать что каждый поток,
использующий поле clientConnected, работает с актуальным, а не кэшированным его
значением.



Чат (11)

Пришло время написать главный метод класса Handler, который будет вызывать все
вспомогательные методы, написанные ранее. Реализуем метод void run() в классе Handler.

Он должен:
1) Выводить сообщение, что установлено новое соединение с удаленным
адресом, который можно получить с помощью метода getRemoteSocketAddress.
2) Создавать Connection, используя поле socket.
3) Вызывать метод, реализующий рукопожатие с клиентом, сохраняя имя нового
клиента.
4) Рассылать всем участникам чата информацию об имени присоединившегося
участника (сообщение с типом USER_ADDED). Подумай, какой метод подойдет для
этого лучше всего.
5) Сообщать новому участнику о существующих участниках.
6) Запускать главный цикл обработки сообщений сервером.
7) Обеспечить закрытие соединения при возникновении исключения.
8) Отловить все исключения типа IOException и ClassNotFoundException, вывести в
консоль информацию, что произошла ошибка при обмене данными с удаленным
адресом.
9) После того как все исключения обработаны, если п.11.3 отработал и возвратил
нам имя, мы должны удалить запись для этого имени из connectionMap и разослать
всем остальным участникам сообщение с типом USER_REMOVED и сохраненным
именем.
10) Последнее, что нужно сделать в методе run() – вывести сообщение,
информирующее что соединение с удаленным адресом закрыто.

Наш сервер полностью готов. Попробуй его запустить.



Чат (10)

Этап третий – главный цикл обработки сообщений сервером.
Добавь приватный метод void serverMainLoop(Connection connection, String userName) throws
IOException, ClassNotFoundException, где значение параметров такое же, как и у метода
sendListOfUsers.

Он должен:
1) Принимать сообщение клиента
2) Если принятое сообщение – это текст (тип TEXT), то формировать новое
текстовое сообщение путем конкатенации: имени клиента, двоеточия, пробела и
текста сообщения. Например, если мы получили сообщение с текстом "привет чат" от
пользователя "Боб", то нужно сформировать сообщение "Боб: привет чат".
3) Отправлять сформированное сообщение всем клиентам с помощью метода
sendBroadcastMessage.
4) Если принятое сообщение не является текстом, вывести сообщение об ошибке
5) Организовать бесконечный цикл, внутрь которого перенести функционал
пунктов 10.1-10.4.



Чат (9)

Этап второй, но не менее важный – отправка клиенту (новому участнику) информации об
остальных клиентах (участниках) чата.

Для этого:
1) Добавь приватный метод void sendListOfUsers(Connection connection, String userName) throws
IOException, где connection – соединение с участником, которому будем слать
информацию, а userName – его имя. Метод должен:
2) Пройтись по connectionMap.
3) У каждого элемента из п.2 получить имя клиента, сформировать команду с типом
USER_ADDED и полученным именем.
4) Отправить сформированную команду через connection.
5) Команду с типом USER_ADDED и именем равным userName отправлять не нужно,
пользователь и так имеет информацию о себе.



Чат (8)

Класс Handler должен реализовывать протокол общения с клиентом.
Выделим из протокола отдельные этапы и реализуем их с помощью отдельных методов:
Этап первый – это этап рукопожатия (знакомства сервера с клиентом). Реализуем его с
помощью приватного метода String serverHandshake(Connection connection) throws IOException,
ClassNotFoundException. Метод в качестве параметра принимает соединение connection, а
возвращает имя нового клиента.

Реализация метода должна:
1)	Сформировать и отправить команду запроса имени пользователя
2)	Получить ответ клиента
3)	Проверить, что получена команда с именем пользователя
4)	Достать из ответа имя, проверить, что оно не пустое и пользователь с таким именем
еще не подключен (используй connectionMap)
5)	Добавить нового пользователя и соединение с ним в connectionMap
6)	Отправить клиенту команду информирующую, что его имя принято
7)	Если какая-то проверка не прошла, заново запросить имя клиента
8)	Вернуть принятое имя в качестве возвращаемого значения
>>>>>>> ec70b27a87d6854e65316b122c5560c063f30757



